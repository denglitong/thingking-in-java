# 初始化与清理

> 在Java中，初始化和创建绑定在一起，两者不能分离  
构造器没有返回值（与返回void是不同的）  

> 重载函数中如果只有一个参数且为基本数据类型，则会设计到基本类型的up cast和down cast的问题  
如果能遇到有匹配的基本数据类型则直接调用对应的重载函数  
如果没有，则会把类型小的入参自动转换为类型大的参数、把类型大的自动转换为类型小的参数（如果不这样则编译器会报错）  
注意char类型向上转型为int  

> f1(byte x)  
f1(short x)  
f1(int x)  
f1(long x)  
f1(float x)  

> f1(char c) 没有与之直接匹配的char入参的重载函数，而char向上转型为int，所以直接调用f1(int x)  
f1(double d) 没有与之直接匹配的double入单的重载函数，double向下转型为float，所以调用f1(float f)  
此处如果f1(float x)的重载函数则再向下转型为long然后调用f1(long l)的函数

> 函数签名只能是函数名+参数列表，不能包含返回值是因为在调用函数的时候可能会忽略返回值  
这会让编译器不知道应该调用哪个函数  

> 同一个方法如何区分接受的消息是来自2个不同的对象？  
：在Java内部，成员函数的第一个隐藏参数是所操作对象的引用，即this关键字  

> 在构造器中调用构造器  
使用this关键字再加上参数列表，则表示将产生对此符合此参数列表的某个构造器的调用

> Java提供一个finalize()方法来提供在垃圾回收之前做一些清理工作：  
一旦垃圾回收器准备好释放对象的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生才会真正回收对象占用的内存    
但切记，finalize()不等于C++中的析构函数，因为：  
1.对象可能不被垃圾回收  
2.垃圾回收不不等于"析构"  
3.垃圾回收只与内存有关  

> finalize()的真正用途：  
由于垃圾回收器都会负责对象占据所有内存的释放工作，不管对象是如何创建的  
但是，如果对于不是对象占用的内存部分，垃圾回收器就不管管理它，这对于Java调用本地方法的情况：  
调用C/C++的本地代码：使用了malloc()函数如果没有显式free()的话会造成内存泄露，所以需要在finalize()进行free()本地方法的调用  

> 如果JVM并没有面临内存耗尽的情况，它是不会浪费时间去执行垃圾回收以恢复内存的  

> 垃圾回收器可以提供Java在堆上分配对象内存的速度：  
Java从堆分配空间的速度，可以和其他语言从栈上分配空间的速度想媲美  
Java维护一个在堆指针，在分配对象内存的时候它只是简单的移动到尚未分配的区域  
垃圾回收器：  
一面回收空间、一面使堆中的对象紧凑排列，这避免了分配太多对象后的内存频繁换页  

> 垃圾回收器的实现：  
理解：对象的引用计数为0的时候释放对象的内存，但是这种方法并未直接用于JVM的实现中  
> 当2个对象循环引用但是它们都并未被用到时，这时它们应该被回收但是其引用计数都不为0  
为此，垃圾回收器基于新的计数技术来确定哪些对象真正的被引用到：  
对任何"活"的对象，一定能最终追溯到其存活在栈上或静态存储区只中的引用，  
所以只需要从栈上火静态存储区中遍历所有引用的对象以及它们依赖的引用对象，就可以把所有"活"的对象给标记到  
从而未标记到的对象就是在当前上下文为被使用的对象而可以进行内存释放  

> 不同的JVM实现：  
1.停止-复制（stop-and-copy）：  
这意味着先暂停程序的运行，然后对象呗复制到新堆中，然后再更新引用  
这样做有2个问题：  
1.1 首先是需要2个堆，这需要JVM去找一块足够大的内存  
1.2 其次是复制，程序运行稳定期间只会产生少量垃圾甚至没有垃圾，但依然需要全部复制  

> 为此，第二种方式出现了：  
2.标记-清扫（mark-and-sweep） 
即上述根据从栈或静态存储空间中标记到的"活"的对象标记完成之后，才会开始清理对象（标记期间不会清理对象）  
但是这样清理之后内存会变得不连续需要重新整理  

> 自适应技术：  
如果运行期间产生的垃圾很少，那么JVM会使用mark-and-sweep模式来进行垃圾的回收，而当内存碎片很多的时候，  
JVM会自动切换到stop-and-copy模式复制到一个新的堆上并使得内存快保持连续

> JVM用以提升速度的附加技术：JIT（Just-In-Time）  
.class文件只有在类被用到的时候才会被编译而不需要让编译器编译所有代码  
这样不会被执行的代码也许就压根不会被JIT所编译，并且代码执行次数越多，它的速度就越快，因为每次执行的时候都会做一些优化  