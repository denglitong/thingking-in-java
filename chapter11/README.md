# 内部类

> 为什么需要内部类  
一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。  
所以可以认为内部类提供了某种进入其外围类的窗口。  

> 内部类必须要回答的一个问题就是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？  
答案是：如果这能满足需求，那么就应该这样做。  
那么内部类实现一个接口与外围类实现这个接口有什么区别呢？  
答案是：后者不是总能享用到接口带来的方便(Why?)，有时需要用到接口的实现。  
所以，使用内部类最吸引人的原因是：  
每个内部类都能独立地继承自一个（接口的）实现，所谓无论外围是否已经继承了某个（接口的）实现，
对于内部类都没有影响。  

> 如果没有内部类提供的、可以继承多个具体的或抽象的能力，一些设计与编程问题就很难解决。  
从这个角度看，内部类使得多重继承的解决方案变得完整。  
接口解决了部分问题，而内部类有效地实现了"多重继承"，也就是内部类允许继承多个非接口类型（类或抽象类）

> 使用内部类，还可以获得其他的一些特性：  
1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立    
2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口或继承同一个类。比如Selector和reverseSelector  
3.创建内部类对象的时刻并不依赖于外围类对象的创建  
4.内部类并没有令人迷惑的is-a关系，它就是一个独立的实体  

> 闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。  
内部类是面向对象的闭包，不仅包含外围类对象的信息，还自动拥有一个指向外围类对象的引用，在此作用域内  
内部类有权操作所有的成员，包括private成员

> Java8之前生成闭包的唯一方式就是内部类，在Java8之后我们可以使用lambda表达式来生成闭包行为

> 模板方法设计模式：模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，已完成算法的动作  
设计模板总是将变化的事务与保持不变的事务分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物

> 编译后每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息  
（此信息产生一个"meta-class"，叫做Class对象）  
内部类也必须生成一个.class文件以包含他们的Class对象信息，有严格的命名：  
Counter.class  
LocalInnerClass$1.class  
LocalInnerClass$1LocalCounter.class
LocalInnerClass.class  
\# 如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符  
如果内部类是嵌套在别的内部类中，只需直接将他妈呢的名字加在其外围类标识符与$的后面

> 比起面向对象编程中其他的概念来，接口和内部类更深奥复杂，比如C++就没有这些。  
将两者结合起来，统一能够解决C++中的用多重集成所能解决的问题。  
然而，事实证明多重继承在C++中是相对难用的，相比较而言，Java的接口和内部类就容易理解多了  

> 就像多态机制一样，什么时候使用应该是涉及阶段考虑的问题  
随着时间的推移，你将能够更好的识别什么情况下应该使用接口、什么情况下使用内部类  