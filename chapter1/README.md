# 对象导论

## 抽象过程

> 人们所能解决的问题的复杂性直接取决于抽象的类型和质量（所谓的类型是指所抽象的是什么）

> 1. 汇编语言 <- 是对底层机器的轻微抽象
> 2. 命令式语言 <- 是对汇编语言的抽象  


>   - 但是建立抽象依然基于计算机的结构，而不是所要解决问题的结构（问题空间（具体业务） <- 抽象 <- 解空间（基于计算机））  
>   - 建立抽象这种映射不属于编程所固有的功能，这是"编程方法"。（知识本身不产生高价值，产生高价值的是建立这种抽象映射的能力，莫不如此）  
>   - 除了对计算机的抽象建模，还有一种方式是只针对带解决问题建模，但是超出问题边界的问题就力不从心了。（DSL等特定领域建模语言）  
>   -  如PROLOG将所有问题都转换成决策链、LISP将所有的问题最终都是列表等  

>   - OOP：将问题空间中的元素及其在解空间中的元素的表示称为"对象"，并且允许通过添加新类型的对象使自身适用于某个特定问题  
>   - 这样，OOP允许根据问题来描述问题，而不是根据允许解决防范的计算机来描述问题
>   - 不过它仍然和计算机有联系，因为每个对象看起来都有点像一台微型计算机 -- 它具有状态和操作，映射到现实世界中的特征和行为

> Smalltalk (第一个成功的面向对象的语言)  
> - 万物皆是对象（可将待求解问题的任何概念化组件作为程序中的对象）  
> - 程序是对象的集合，他们通过发送消息来告知彼此所构成的存储
> - 每个对象都有自己的由其他的对象所构成的存储（可包含已有对象，将复杂性隐藏在对象的简单性背后）
> - 每个对象都拥有其类型（对象是类型的实例，每个类型的区别其他类型的特征就是可以发送什么样的消息给它，PS:比如遇到什么人就该以什么样的方式与之相处）
> - 某一特定类型的所有对象都可以接收同样的消息（继承类型可以替代父类型所出现的位置，这种可替代性是OOP最强有力的概念之一）

> 对象具有状态、行为和标志
> - 状态：对象内部所拥有的数据和方法
> - 行为：对象内部持有的方法产生行为
> - 标识：每个对象在内存中都有一个唯一的地址


## 每个对象都有一个接口

        当看到类型一词时，可见其作为类来考虑，反之亦然。但是另一些人对此有另外的看法，
        他们认为，类型决定了接口 interface，而类 class 是该接口的一个特定实现。

> 任何程序都是你所设计的系统的一种仿真

## 每个对象都提供服务

> 设计一个程序时，最好的方法之一就是将对象想象为"为服务提供者"，程序本身将向用户提供服务，  
它将通过调用其他的对象提供的服务来实现这一目的。你的目标就是去创建能够提供理想的服务来解决问题的一系列对象。

> 将对象看做是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。  
在良好的面对对象程序设计中，每个对象都可以很好的完成一项任务，但是它并不视图做更多的事。

## 被隐藏的具体实现

> 将程序开发人员按照角色分为类创建者（那些创建数据类型的程序员）和客户端程序员（那些在其应用终使用数据类型的类消费者）是大有裨益的。  
类创建者：目标是构建类，只暴露必须提供的部分而隐藏其他部分。  
类消费者：采集各种用来快速实现应用开发的类。  
对于程序开发人员要区分这2种角色，因为很多时候这2中角色都是由同一批人甚至同一个人来承担。

> 访问控制 -- 在具有关系所设计的各方都遵守一个便捷是十分重要的事情  
> - 让客户端程序员无法触及他们不应该触及的部分，这部分并不是用户所解决问题所需接口的一部分
> - 允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员

> Java的访问控制：public, protected, private，还有一个默认的包访问权限（包内类可见）

## 复用具体实现

> 一旦类被创建好，那么它在理想情况下就应该代表一个有用的代码单元，理应可以被复用。  
使用现成的类组成新的类，称之为组合 composition，被视为"has a"关系。  
在建立新类时，在继承和组合之间应首先考虑组合，但也要视具体情况而定
