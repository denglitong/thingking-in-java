# 对象导论

## 抽象过程

> 人们所能解决的问题的复杂性直接取决于抽象的类型和质量（所谓的类型是指所抽象的是什么）

> 1. 汇编语言 <- 是对底层机器的轻微抽象
> 2. 命令式语言 <- 是对汇编语言的抽象  


>   - 但是建立抽象依然基于计算机的结构，而不是所要解决问题的结构（问题空间（具体业务） <- 抽象 <- 解空间（基于计算机））  
>   - 建立抽象这种映射不属于编程所固有的功能，这是"编程方法"。（知识本身不产生高价值，产生高价值的是建立这种抽象映射的能力，莫不如此）  
>   - 除了对计算机的抽象建模，还有一种方式是只针对带解决问题建模，但是超出问题边界的问题就力不从心了。（DSL等特定领域建模语言）  
>   -  如PROLOG将所有问题都转换成决策链、LISP将所有的问题最终都是列表等  

>   - OOP：将问题空间中的元素及其在解空间中的元素的表示称为"对象"，并且允许通过添加新类型的对象使自身适用于某个特定问题  
>   - 这样，OOP允许根据问题来描述问题，而不是根据允许解决防范的计算机来描述问题
>   - 不过它仍然和计算机有联系，因为每个对象看起来都有点像一台微型计算机 -- 它具有状态和操作，映射到现实世界中的特征和行为

> Smalltalk (第一个成功的面向对象的语言)  
> - 万物皆是对象（可将待求解问题的任何概念化组件作为程序中的对象）  
> - 程序是对象的集合，他们通过发送消息来告知彼此所构成的存储
> - 每个对象都有自己的由其他的对象所构成的存储（可包含已有对象，将复杂性隐藏在对象的简单性背后）
> - 每个对象都拥有其类型（对象是类型的实例，每个类型的区别其他类型的特征就是可以发送什么样的消息给它，PS:比如遇到什么人就该以什么样的方式与之相处）
> - 某一特定类型的所有对象都可以接收同样的消息（继承类型可以替代父类型所出现的位置，这种可替代性是OOP最强有力的概念之一）

> 对象具有状态、行为和标志
> - 状态：对象内部所拥有的数据和方法
> - 行为：对象内部持有的方法产生行为
> - 标识：每个对象在内存中都有一个唯一的地址


## 每个对象都有一个接口

        当看到类型一词时，可见其作为类来考虑，反之亦然。但是另一些人对此有另外的看法，
        他们认为，类型决定了接口 interface，而类 class 是该接口的一个特定实现。

> 任何程序都是你所设计的系统的一种仿真

## 每个对象都提供服务

> 设计一个程序时，最好的方法之一就是将对象想象为"为服务提供者"，程序本身将向用户提供服务，  
它将通过调用其他的对象提供的服务来实现这一目的。你的目标就是去创建能够提供理想的服务来解决问题的一系列对象。

> 将对象看做是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。  
在良好的面对对象程序设计中，每个对象都可以很好的完成一项任务，但是它并不视图做更多的事。

## 被隐藏的具体实现

> 将程序开发人员按照角色分为类创建者（那些创建数据类型的程序员）和客户端程序员（那些在其应用终使用数据类型的类消费者）是大有裨益的。  
类创建者：目标是构建类，只暴露必须提供的部分而隐藏其他部分。  
类消费者：采集各种用来快速实现应用开发的类。  
对于程序开发人员要区分这2种角色，因为很多时候这2中角色都是由同一批人甚至同一个人来承担。

> 访问控制 -- 在具有关系所设计的各方都遵守一个便捷是十分重要的事情  
> - 让客户端程序员无法触及他们不应该触及的部分，这部分并不是用户所解决问题所需接口的一部分
> - 允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员

> Java的访问控制：public, protected, private，还有一个默认的包访问权限（包内类可见）

## 复用具体实现

> 一旦类被创建好，那么它在理想情况下就应该代表一个有用的代码单元，理应可以被复用。  
使用现成的类组成新的类，称之为组合 composition，被视为"has a"关系。  
在建立新类时，在继承和组合之间应首先考虑组合，但也要视具体情况而定

## 继承

> 对象：数据+功能 -> 灵活的描述问题空间的概念  
继承：复用基类，导出类与基类具有相同的类型，继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛  
相同的类型是指，具有相同的基础接口

> is-a: 纯粹继承，代替原则，及子类和基类的接口方法完全相同，子类只是对基类的方法进行override  
> is-like-a：子类扩展了新的方法，这使得基类的接口类型中无法知道子类扩展了什么方法，自然也访问不到新方法  
如果出现了is-like-a的继承关系，是时候审视一下基类的划分是否足够纯粹了

## 伴随多态的可互换对象

> 在处理类型的层次结构时，经常用基类的句柄去指向具体的特定类型，这使人们可以编写出不依赖于特定类型的代码，添加新类型是面向对象程序设计最常用的方式  

> 泛化的函数调用：编译器不可能产生传统意义上的函数调用（前期绑定），而是使用后期绑定，知道运行时被调用的代码才能确定，从而对应的函数才绑定到具体代码的内存地址上

> 向上转型(up-cast): 子类转型为基类

## 单继承结构
> 单继承结构使得结构中的所有对象都具有一个共用接口  
单继承结构保证所有的对象都具备某些功能 - 堆上创建，参数简化  
单继承结构使垃圾回收器的事项变得容易得多 - 类型推断总是容易的

## 容器

> 集合 -> 容器, List(列表存储序列), Map, Set(每种对象类型只有一个), Queue, Tree, Stack

> 参数化类型：  
置入对象引用到容器中时，对象向上转型为Object，取出时需向下转型为具体对象引用类型  
这个时候需要记住具体对象的类型信息，因为向下转型通常是不安全的，这个解决方案叫做参数化类型机制，如 ArrayList\<Shape> list = new ArrayList\<Shape\>(), 这也叫泛型

## 对象的创建和生命周期

> 使用对象的关键问题就是它们的生成和销毁方式  
为了追求最大的执行速度，对象的存储空间和生命周期可在编写程序时确定，对象将分配在栈上，然后依赖在程序中手动删除，比如C++，提供了灵活性但是增加了复杂度  
第二种方式是在堆中创建对象，在运行时才知道何时创建对象、生命周期及其类型  
提供在栈上创建对象的语言，对堆上的对象一无所知，而Java通过在堆上创建对象，提供了垃圾回收机制，使得使用对象更为简单
