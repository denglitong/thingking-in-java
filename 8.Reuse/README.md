# 复用

> 代码复用是OOP最具魅力的原因之一  
组合（Composition），has-a，复用代码的功能而非形式    
继承（Inheritance），is-a，基于现有类型创建新类

> OOP编程三大特性：封装、继承、多态

> Java不直接支持的第三种重用关系成为委托，这介于继承和组合之间  
委托给某个子类的对象，可以使用子类对象的方法子集和有更多的控制权  

> 当你想在新类中包含一个已有类的功能时，使用组合，而非继承  
新类使用者看到的是你所定义的新类的接口，而非嵌入式对象的接口  

> protected 对类的使用者是private的，对类的继承者是可见的，同时具有包可见性  
继承最重要的不是为新类提供方法，新类是已有类的一种类型  

> 继承其实不太常用，并且尽量少使用它  
一种判断是使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类  
如果必须向上转型，那么继承就是必要的（多态是使用向上转型最有力的理由）  
如果不需要向上转型，那么就需要考虑组合  

> final 基本类型 -> 基本类型的值不变  
static final -> 属性会占用一段不能改变的存储空间  
final Object -> 对对象的引用不能改变，不能再指向其他对象      
final arg -> 将参数声明伪final意味着不能改变参数的值  

> final 方法：  
1.给方法上锁防止子类覆盖该方法的行为  
2.效率：final方法会将方法体直接替换到被调用的地方而不是进行方法压栈执行等  
但是这种优化的效率在小方法才明显，如果方法执行时间超过方法压栈很多则这种优化就不明显了  
但是最近的JVM版本中可以探测这种情况（hotspot技术）并优化去掉这些内嵌调用方法  
应该让编译器和JVM处理效率问题，只有在防止方法被覆盖时才用final  
private方法因为无法被访问，所以本身就隐式的包含了final因为不能被改变  

> 在Java后只能怪，类的代码在首次使用时加载  
类的构造器也是一个static方法（隐式static），因此准确的说一个类当它任意一个static成员被访问时类就会被加载  

> 组合将已有类型作为新类型底层实现的一部分  
继承复用的是接口  

> 在设计一个系统时，目标是发现或创建一系列类，每个类有特定的用途，
而且既不应太大（包括太多功能难以复用），也不应太小（不添加其他功能就无法使用）。  
如果设计变得过的复杂，通过将现有类拆分为更小的部分而添加更多的对象  

> 设计系统、程序开发是一个增量过程，继承和组合正是可用进行增量调整的最基本的2个工具
