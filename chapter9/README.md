# 多态

> OOP: 封装、继承、多态    
多态：接口和实现分离：解耦做什么和怎么做  
多态有助于创建具有可扩展行的程序

> 封装通过合并特征和行为来创建新的数据类型，隐藏实现通过将细节私有化以将接口和实现分离  
继承允许将一个对象视为它的基类类型，这样就能把很多派生类当做基类的同一类型处理  
多态：动态绑定

> 多态：忘掉具体类型，只与基类打交道  
给对象发送一条消息，让对象自己做正确的事  

> 绑定：将一个方法调用和一个方法主体关联起来   
前期绑定：绑定发生在程序运行之前（如果有的话，由编译器和链接器实现）  
后期绑定：在运行时根据对象的类型进行绑定  

> 多态只是针对方法的，属性值在子类和基类中都被编译器解析因而子类和基类的属性值被分配了不同的存储空间  
静态方法也不具有多态性  

> 对象的构造器调用顺序：  
1.基类构造器被调用，这个步骤重复递归直到跟基类的构造器被调用，然后是它的派生类，以此类推，直到最底层的派生类的构造器被调用（此时还没调用）  
2.按声明顺序初始化成员（这一步在调用构造器之前）  
3.最终调用派生类的构造器  

> 清理的顺序与声明的顺序想法，首先进行派生类的清理，然后才是基类的清理  
这是因为派生类的清理可能会调用基类的一些方法，如果基类此时需要存活，不能被过早的销毁  

> 构造器内部多态方法的行为：  
在派生类的构造器中，会调用基类型的构造方法，如果这时候基类型的构造方法调用了派生类的方法，  
此时派生类只是部分初始化，这会带来灾难。  

> 初始化过程：  
1.在所有事情发生之前，分配给对象的存储空间会被初始化为二进制0  
2.调用基类构造器初始化基类，如果基类此时调用了派生类的重写方法，里面用到的派生类属性值只能是初始值0  
3.按声明顺序初始化成员  
4.最终调用派生类的构造器  

> 编写构造器的良好规范：  
做尽量少的事让对象进入良好状态  
如果有可能的话，尽量不要调用类中的任何方法  
在构造器中唯一安全调用的只有基类的final方法（private方法是隐式的final方法）  

> 设计：更好的方法是首先是要组合，选择继承时先考虑你是否需要向上转型  
一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化  