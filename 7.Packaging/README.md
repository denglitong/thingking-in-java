# 封装

> 包的使用者期望包版本升级代码是不需要改动的，这通过约定实现：包版本升级不会移除已有的方法  

> 访问权限从大到小是: public, protected, 包访问权限（没有关键字）和 private  
public/protected包外可见，public包外任何类可见，protected子类可见  
包访问权限/private包内可见，包访问权限包内任何类可见，private限包内限本类可见

> 一个Java文件是一个编译单元，一个Java文件中只能有一个public类，否则编译器不接受，  
类名和文件名必须相同，如果这个编译单元中海油其他类，那么在包之外是无法访问到这些类的  
编译单元只支持主public类对包外可见

> 当编译一个 .java 文件时，.java 文件的每个类都有一个对应的 .class 输出文件  
与c/c++的编译中间文件（obj文件）然后再由链接器链接不同，在 Java 中，  
可运行程序是一组 .class 文件，它们可以打包压缩成一个 Java 文档文件（如JAR）  
Java 解释器负责查找、加载和解释这些 .class 文件

> 类库就是一组类文件，也可以说是一组 .class 文件

> 包名一律小写，多个单词连着也是一样  

> Java 解释器加载一个 .class 文件时，会在 CLASSPATH 中根据包名解析成对应的路径去目录下  
查找对应的类文件，如com.denglitong.MyClass.java 会在 CLASSPATH 下的 com/denglitong目录查找 MyClass.class 文件  

> 如果要将一个 jar 包添加到 classpath 中，需要填写 jar 包的绝对路径，而不只是所在目录，如：  
CLASSPATH=.;/usr/local/java/;/usr/local/grape.jar;  
多个 classpath 用;分隔  

> gradlew 命令管理自身的 classpath

> 如果导入了2个包含相同的类的包，那么在未使用到冲突类的时候是不会暴露冲突的问题的  
如果需要使用到冲突的类，就需要指定类的绝对包名了

> 如果没有给类指定包名，则 JVM 会类放到默认包中

> 访问控制：实现的隐藏，将数据和方法包装进类中并把具体实现隐藏，这就是封装  
内部访问控制在数据类型内部划定了边界：  
1.确定类的使用者可以使用和不能使用的边界，可以在结构中建立自己的内部机制而不必担心类的使用者涉及到内部实现机制 ->    
2.将接口和实现分离  

> 一种创建类的风格是public成员方在类的开头，接着是protected成员、包访问权限成员、最后是private成员  
这样类的使用者从头读起，首先会看到他们关心的public部分，直到遇到非public时停止，因为接下来是内部实现了  

> 类的访问权限只能是public和包访问权限，不能是private/protected  
为防止类被外界访问，你可以将所有的构造器都声明为private，这样只有你才能创建对象（在类的static成员中）

> JVM会为你构建一个默认的无参构造器，但是如果你自己声明了一个无参构造器那么编译器就不会自动创建构造器了  
这时将构造器声明为private则不能通过调用构造器来创建对象